#!/bin/bash

# IUM Development Environment CLI Tool
# This script provides intelligent PHP command execution and hosts file management

set -e

# Configuration
DOCKER_COMPOSE_DIR="/home/erfan/Desktop/ium"
WWW_DIR="$DOCKER_COMPOSE_DIR/www"
CONTAINER_NAME="ium-php-apache"
HOSTS_FILE="/etc/hosts"
IUM_MARKER="# IUM Development Environment"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}[IUM]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[IUM]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[IUM]${NC} $1"
}

print_error() {
    echo -e "${RED}[IUM]${NC} $1"
}

# Function to detect PHP version from current directory
detect_php_version() {
    local current_dir=$(pwd)
    
    # Check if we're inside the www directory
    if [[ "$current_dir" == *"$WWW_DIR"* ]]; then
        # Extract the part after www/
        local relative_path=${current_dir#$WWW_DIR/}
        
        # Extract PHP version (first directory component)
        local php_version=$(echo "$relative_path" | cut -d'/' -f1)
        
        # Validate PHP version
        if [[ "$php_version" =~ ^php[0-9]+$ ]]; then
            echo "$php_version"
            return 0
        fi
    fi
    
    # Default fallback
    echo "php84"
    return 1
}

# Function to get app name from current directory
get_app_name() {
    local current_dir=$(pwd)
    
    # Check if we're inside the www directory
    if [[ "$current_dir" == *"$WWW_DIR"* ]]; then
        # Extract the part after www/phpXX/
        local relative_path=${current_dir#$WWW_DIR/}
        
        # Remove PHP version prefix
        local without_php=$(echo "$relative_path" | sed 's/^php[0-9]*\///')
        
        # Extract app name (first directory component)
        local app_name=$(echo "$without_php" | cut -d'/' -f1)
        
        if [[ -n "$app_name" && "$app_name" != "." ]]; then
            echo "$app_name"
            return 0
        fi
    fi
    
    return 1
}

# Function to execute command in container
execute_command() {
    local php_version=$1
    shift
    local command="$@"
    
    print_info "Executing command in $php_version environment: $command"
    
    # Check if container is running
    if ! docker ps --format "table {{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        print_error "Container $CONTAINER_NAME is not running. Please start it with: cd $DOCKER_COMPOSE_DIR && docker compose up -d"
        exit 1
    fi
    
    # Set environment variables for the PHP version
    local php_env=""
    case $php_version in
        php74)
            php_env="PATH=/usr/bin:$PATH PHP_VERSION=7.4"
            ;;
        php84)
            php_env="PATH=/usr/bin:$PATH PHP_VERSION=8.4"
            ;;
        *)
            print_error "Unsupported PHP version: $php_version"
            exit 1
            ;;
    esac
    
    # Get current directory relative to www
    local current_dir=$(pwd)
    local container_workdir="/var/www/html"
    
    if [[ "$current_dir" == *"$WWW_DIR"* ]]; then
        local relative_path=${current_dir#$WWW_DIR}
        container_workdir="/var/www/html$relative_path"
    fi
    
    # Handle special commands that need PHP version context
    if [[ "$command" == php* ]]; then
        # Replace 'php' with the version-specific binary
        local php_binary
        case $php_version in
            php74)
                php_binary="/usr/bin/php7.4"
                ;;
            php84)
                php_binary="/usr/bin/php8.4"
                ;;
        esac
        command="${command/php/$php_binary}"
    elif [[ "$command" == composer* ]]; then
        # Ensure composer uses the correct PHP version
        local php_binary
        case $php_version in
            php74)
                php_binary="/usr/bin/php7.4"
                ;;
            php84)
                php_binary="/usr/bin/php8.4"
                ;;
        esac
        command="$php_binary /usr/local/bin/composer ${command#composer }"
    fi
    
    # Execute command in container with proper environment
    docker exec -it -w "$container_workdir" -e "$php_env" "$CONTAINER_NAME" bash -c "$command"
}

# Function to scan for applications
scan_applications() {
    local apps=()
    
    if [[ ! -d "$WWW_DIR" ]]; then
        print_warning "WWW directory not found: $WWW_DIR"
        return
    fi
    
    # Scan PHP version directories
    for php_dir in "$WWW_DIR"/php*/; do
        if [[ -d "$php_dir" ]]; then
            # Scan for app directories
            for app_dir in "$php_dir"*/; do
                if [[ -d "$app_dir" ]]; then
                    local app_name=$(basename "$app_dir")
                    if [[ "$app_name" != "." && "$app_name" != ".." ]]; then
                        apps+=("$app_name")
                    fi
                fi
            done
        fi
    done
    
    # Remove duplicates and sort
    printf '%s\n' "${apps[@]}" | sort -u
}

# Function to start containers (wake)
wake_containers() {
    print_info "Starting IUM development environment..."
    
    if ! docker compose version &> /dev/null; then
        print_error "Docker Compose is not available. Please ensure Docker is installed and running."
        exit 1
    fi
    
    cd "$DOCKER_COMPOSE_DIR"
    
    # Check if containers are already running
    if docker compose ps --services --filter "status=running" | grep -q .; then
        print_warning "Some containers are already running"
        docker compose ps
        return
    fi
    
    print_info "Building and starting containers..."
    docker compose up -d
    
    # Wait a moment for services to initialize
    print_info "Waiting for services to initialize..."
    sleep 5
    
    # Check status
    if docker compose ps --services --filter "status=running" | grep -q .; then
        print_success "Development environment is now running!"
        docker compose ps
    else
        print_error "Failed to start some services. Check logs with: docker compose logs"
        exit 1
    fi
}

# Function to stop containers (sleep)
sleep_containers() {
    print_info "Stopping IUM development environment..."
    
    cd "$DOCKER_COMPOSE_DIR"
    
    # Check if any containers are running
    if ! docker compose ps --services --filter "status=running" | grep -q .; then
        print_warning "No containers are currently running"
        return
    fi
    
    print_info "Stopping all containers..."
    docker compose down
    
    print_success "Development environment has been stopped"
}

# Function to rebuild containers (reborn)
reborn_containers() {
    print_info "Rebuilding IUM development environment..."
    
    if ! docker compose version &> /dev/null; then
        print_error "Docker Compose is not available. Please ensure Docker is installed and running."
        exit 1
    fi
    
    cd "$DOCKER_COMPOSE_DIR"
    
    print_info "Stopping existing containers..."
    docker compose down
    
    print_info "Removing existing images and rebuilding..."
    docker compose build --no-cache
    
    print_info "Starting rebuilt containers..."
    docker compose up -d
    
    # Wait for services to initialize
    print_info "Waiting for services to initialize..."
    sleep 10
    
    # Test installations
    print_info "Testing PHP installations..."
    if docker exec "$CONTAINER_NAME" php7.4 --version &> /dev/null; then
        print_success "PHP 7.4 is working"
    else
        print_error "PHP 7.4 installation failed"
    fi
    
    if docker exec "$CONTAINER_NAME" php8.4 --version &> /dev/null; then
        print_success "PHP 8.4 is working"
    else
        print_error "PHP 8.4 installation failed"
    fi
    
    # Test Composer
    print_info "Testing Composer installations..."
    if docker exec "$CONTAINER_NAME" php7.4 /usr/local/bin/composer --version &> /dev/null; then
        print_success "Composer with PHP 7.4 is working"
    else
        print_warning "Composer with PHP 7.4 may have issues"
    fi
    
    if docker exec "$CONTAINER_NAME" php8.4 /usr/local/bin/composer --version &> /dev/null; then
        print_success "Composer with PHP 8.4 is working"
    else
        print_warning "Composer with PHP 8.4 may have issues"
    fi
    
    # Check final status
    if docker compose ps --services --filter "status=running" | grep -q .; then
        print_success "Environment successfully rebuilt and running!"
        docker compose ps
    else
        print_error "Failed to start some services after rebuild. Check logs with: docker compose logs"
        exit 1
    fi
}

# Function to reload services with updated configuration
reload_services() {
    print_info "Reloading IUM services with updated configuration..."
    
    if ! docker compose version &> /dev/null; then
        print_error "Docker Compose is not available. Please ensure Docker is installed and running."
        exit 1
    fi
    
    cd "$DOCKER_COMPOSE_DIR"
    
    print_info "Restarting containers to apply configuration changes..."
    docker compose restart
    
    # Wait for services to initialize
    print_info "Waiting for services to initialize..."
    sleep 5
    
    # Reload Apache configuration
    print_info "Reloading Apache configuration..."
    docker exec "$CONTAINER_NAME" supervisorctl reload || print_warning "Failed to reload supervisor - services may need manual restart"
    
    # Restart PHP-FPM services
    print_info "Restarting PHP-FPM services..."
    docker exec "$CONTAINER_NAME" supervisorctl restart php7.4-fpm || print_warning "Failed to restart PHP 7.4 FPM"
    docker exec "$CONTAINER_NAME" supervisorctl restart php8.4-fpm || print_warning "Failed to restart PHP 8.4 FPM"
    
    # Restart Apache
    print_info "Restarting Apache..."
    docker exec "$CONTAINER_NAME" supervisorctl restart apache2 || print_warning "Failed to restart Apache"
    
    print_success "Configuration reload completed!"
    print_info "Updated configuration files are now active"
    
    # Update hosts file too
    update_hosts_file
}

# Function to update hosts file
update_hosts_file() {
    print_info "Scanning for applications..."
    
    local apps=($(scan_applications))
    
    if [[ ${#apps[@]} -eq 0 ]]; then
        print_warning "No applications found to add to hosts file"
        return
    fi
    
    print_info "Found ${#apps[@]} applications: ${apps[*]}"
    
    # Check if we need sudo
    if [[ ! -w "$HOSTS_FILE" ]]; then
        print_info "Requesting sudo access to modify $HOSTS_FILE"
        
        # Create temporary file with new entries
        local temp_file=$(mktemp)
        
        # Copy existing hosts file without IUM entries
        grep -v "$IUM_MARKER" "$HOSTS_FILE" > "$temp_file" 2>/dev/null || true
        
        # Add IUM marker and entries
        echo "" >> "$temp_file"
        echo "$IUM_MARKER - Start" >> "$temp_file"
        
        for app in "${apps[@]}"; do
            echo "127.0.0.1    $app.local" >> "$temp_file"
        done
        
        echo "$IUM_MARKER - End" >> "$temp_file"
        
        # Update hosts file with sudo
        sudo cp "$temp_file" "$HOSTS_FILE"
        rm "$temp_file"
    else
        # Direct modification (probably won't happen, but just in case)
        print_error "Cannot write to hosts file. Please run with appropriate permissions."
        exit 1
    fi
    
    print_success "Updated hosts file with ${#apps[@]} applications"
    
    # Show added entries
    print_info "Added the following entries:"
    for app in "${apps[@]}"; do
        echo "  $app.local -> 127.0.0.1"
    done
}

# Function to show help
show_help() {
    echo "IUM Development Environment CLI Tool"
    echo ""
    echo "Usage:"
    echo "  ium <command>           Execute any command in detected environment"
    echo "  ium wake                Start all containers"
    echo "  ium sleep               Stop all containers"
    echo "  ium reborn              Rebuild and restart all containers"
    echo "  ium reload              Reload services with updated configuration and hosts"
    echo "  ium status              Show environment status"
    echo "  ium help                Show this help message"
    echo ""
    echo "Container Management:"
    echo "  ium wake                Start the development environment"
    echo "  ium sleep               Stop the development environment"
    echo "  ium reborn              Rebuild containers from scratch"
    echo ""
    echo "Examples:"
    echo "  ium wake                Start all services"
    echo "  ium reborn              Rebuild after Dockerfile changes"
    echo "  ium php -v              Show PHP version"
    echo "  ium php artisan about   Run Laravel Artisan command"
    echo "  ium composer install    Install Composer dependencies"
    echo "  ium npm install         Install NPM dependencies"
    echo "  ium git status          Check git status"
    echo "  ium ls -la              List files in container"
    echo "  ium bash                Open interactive shell"
    echo "  ium reload              Restart services with updated config files"
    echo "  ium sleep               Stop all services"
    echo ""
    echo "Notes:"
    echo "  - Run commands from within your application directory"
    echo "  - PHP version is automatically detected from directory structure"
    echo "  - Commands are executed inside the container with proper context"
    echo "  - Applications are accessible via <appname>.local domains"
    echo "  - Use 'reborn' after making changes to Dockerfile or configs"
    echo ""
}

# Function to show status
show_status() {
    print_info "IUM Development Environment Status"
    echo ""
    
    # Check Docker Compose
    if docker compose -f "$DOCKER_COMPOSE_DIR/docker-compose.yml" ps --services --filter "status=running" | grep -q .; then
        print_success "Docker Compose services are running"
        docker compose -f "$DOCKER_COMPOSE_DIR/docker-compose.yml" ps
    else
        print_warning "Docker Compose services are not running"
        echo "Start with: cd $DOCKER_COMPOSE_DIR && docker compose up -d"
    fi
    
    echo ""
    
    # Show detected environment
    local php_version=$(detect_php_version)
    local app_name=$(get_app_name)
    
    print_info "Current Environment:"
    echo "  PHP Version: $php_version"
    if [[ -n "$app_name" ]]; then
        echo "  Application: $app_name"
        echo "  URL: http://$app_name.local"
    else
        echo "  Application: Not in app directory"
    fi
    
    echo ""
    
    # Show available applications
    local apps=($(scan_applications))
    if [[ ${#apps[@]} -gt 0 ]]; then
        print_info "Available Applications:"
        for app in "${apps[@]}"; do
            echo "  $app -> http://$app.local"
        done
    else
        print_warning "No applications found"
    fi
}

# Main script logic
main() {
    case "${1:-help}" in
        "wake")
            wake_containers
            ;;
        "sleep")
            sleep_containers
            ;;
        "reborn")
            reborn_containers
            ;;
        "reload")
            reload_services
            ;;
        "help"|"--help"|"-h")
            show_help
            ;;
        "status")
            show_status
            ;;
        *)
            # Execute command
            local php_version=$(detect_php_version)
            local app_name=$(get_app_name)
            
            if [[ $? -ne 0 && -z "$app_name" ]]; then
                print_warning "Not in an application directory. Using default PHP version: $php_version"
            fi
            
            execute_command "$php_version" "$@"
            ;;
    esac
}

# Run main function with all arguments
main "$@"
