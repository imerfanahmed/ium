#!/bin/bash

# IUM Development Environment CLI Tool
# This script provides intelligent PHP command execution and hosts file management

set -e

# Configuration
DOCKER_COMPOSE_DIR="/home/erfan/Desktop/ium"
WWW_DIR="$DOCKER_COMPOSE_DIR/www"
CONTAINER_NAME="ium-php-apache"
HOSTS_FILE="/etc/hosts"
IUM_MARKER="# IUM Development Environment"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}[IUM]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[IUM]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[IUM]${NC} $1"
}

print_error() {
    echo -e "${RED}[IUM]${NC} $1"
}

# Function to detect PHP version from current directory
detect_php_version() {
    local current_dir=$(pwd)
    
    # Check if we're inside the www directory
    if [[ "$current_dir" == *"$WWW_DIR"* ]]; then
        # Extract the part after www/
        local relative_path=${current_dir#$WWW_DIR/}
        
        # Extract PHP version (first directory component)
        local php_version=$(echo "$relative_path" | cut -d'/' -f1)
        
        # Validate PHP version
        if [[ "$php_version" =~ ^php[0-9]+$ ]]; then
            echo "$php_version"
            return 0
        fi
    fi
    
    # Default fallback
    echo "php84"
    return 1
}

# Function to get app name from current directory
get_app_name() {
    local current_dir=$(pwd)
    
    # Check if we're inside the www directory
    if [[ "$current_dir" == *"$WWW_DIR"* ]]; then
        # Extract the part after www/phpXX/
        local relative_path=${current_dir#$WWW_DIR/}
        
        # Remove PHP version prefix
        local without_php=$(echo "$relative_path" | sed 's/^php[0-9]*\///')
        
        # Extract app name (first directory component)
        local app_name=$(echo "$without_php" | cut -d'/' -f1)
        
        if [[ -n "$app_name" && "$app_name" != "." ]]; then
            echo "$app_name"
            return 0
        fi
    fi
    
    return 1
}

# Function to execute command in container
execute_command() {
    local php_version=$1
    shift
    local command="$@"
    
    print_info "Executing command in $php_version environment: $command"
    
    # Check if container is running
    if ! docker ps --format "table {{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        print_error "Container $CONTAINER_NAME is not running. Please start it with: cd $DOCKER_COMPOSE_DIR && docker compose up -d"
        exit 1
    fi
    
    # Set environment variables for the PHP version
    local php_env=""
    case $php_version in
        php74)
            php_env="PATH=/usr/bin:$PATH PHP_VERSION=7.4"
            ;;
        php84)
            php_env="PATH=/usr/bin:$PATH PHP_VERSION=8.4"
            ;;
        *)
            print_error "Unsupported PHP version: $php_version"
            exit 1
            ;;
    esac
    
    # Get current directory relative to www
    local current_dir=$(pwd)
    local container_workdir="/var/www/html"
    
    if [[ "$current_dir" == *"$WWW_DIR"* ]]; then
        local relative_path=${current_dir#$WWW_DIR}
        container_workdir="/var/www/html$relative_path"
    fi
    
    # Handle special commands that need PHP version context
    if [[ "$command" == php* ]]; then
        # Replace 'php' with the version-specific binary
        local php_binary
        case $php_version in
            php74)
                php_binary="/usr/bin/php7.4"
                ;;
            php84)
                php_binary="/usr/bin/php8.4"
                ;;
        esac
        command="${command/php/$php_binary}"
    elif [[ "$command" == composer* ]]; then
        # Ensure composer uses the correct PHP version
        local php_binary
        case $php_version in
            php74)
                php_binary="/usr/bin/php7.4"
                ;;
            php84)
                php_binary="/usr/bin/php8.4"
                ;;
        esac
        command="$php_binary /usr/local/bin/composer ${command#composer }"
    fi
    
    # Execute command in container with proper environment
    docker exec -it -w "$container_workdir" -e "$php_env" "$CONTAINER_NAME" bash -c "$command"
}

# Function to scan for applications
scan_applications() {
    local apps=()
    
    if [[ ! -d "$WWW_DIR" ]]; then
        print_warning "WWW directory not found: $WWW_DIR"
        return
    fi
    
    # Scan PHP version directories
    for php_dir in "$WWW_DIR"/php*/; do
        if [[ -d "$php_dir" ]]; then
            # Scan for app directories
            for app_dir in "$php_dir"*/; do
                if [[ -d "$app_dir" ]]; then
                    local app_name=$(basename "$app_dir")
                    if [[ "$app_name" != "." && "$app_name" != ".." ]]; then
                        apps+=("$app_name")
                    fi
                fi
            done
        fi
    done
    
    # Remove duplicates and sort
    printf '%s\n' "${apps[@]}" | sort -u
}

# Function to start containers (wake)
wake_containers() {
    print_info "Starting IUM development environment..."
    
    if ! docker compose version &> /dev/null; then
        print_error "Docker Compose is not available. Please ensure Docker is installed and running."
        exit 1
    fi
    
    cd "$DOCKER_COMPOSE_DIR"
    
    # Check if containers are already running
    if docker compose ps --services --filter "status=running" | grep -q .; then
        print_warning "Some containers are already running"
        docker compose ps
        return
    fi
    
    print_info "Building and starting containers..."
    docker compose up -d
    
    # Wait a moment for services to initialize
    print_info "Waiting for services to initialize..."
    sleep 5
    
    # Check status
    if docker compose ps --services --filter "status=running" | grep -q .; then
        print_success "Development environment is now running!"
        docker compose ps
    else
        print_error "Failed to start some services. Check logs with: docker compose logs"
        exit 1
    fi
}

# Function to stop containers (sleep)
sleep_containers() {
    print_info "Stopping IUM development environment..."
    
    cd "$DOCKER_COMPOSE_DIR"
    
    # Check if any containers are running
    if ! docker compose ps --services --filter "status=running" | grep -q .; then
        print_warning "No containers are currently running"
        return
    fi
    
    print_info "Stopping all containers..."
    docker compose down
    
    print_success "Development environment has been stopped"
}

# Function to rebuild containers (reborn)
reborn_containers() {
    print_info "Rebuilding IUM development environment..."
    
    if ! docker compose version &> /dev/null; then
        print_error "Docker Compose is not available. Please ensure Docker is installed and running."
        exit 1
    fi
    
    cd "$DOCKER_COMPOSE_DIR"
    
    print_info "Stopping existing containers..."
    docker compose down
    
    print_info "Removing existing images and rebuilding..."
    docker compose build --no-cache
    
    print_info "Starting rebuilt containers..."
    docker compose up -d
    
    # Wait for services to initialize
    print_info "Waiting for services to initialize..."
    sleep 10
    
    # Test installations
    print_info "Testing PHP installations..."
    if docker exec "$CONTAINER_NAME" php7.4 --version &> /dev/null; then
        print_success "PHP 7.4 is working"
    else
        print_error "PHP 7.4 installation failed"
    fi
    
    if docker exec "$CONTAINER_NAME" php8.4 --version &> /dev/null; then
        print_success "PHP 8.4 is working"
    else
        print_error "PHP 8.4 installation failed"
    fi
    
    # Test Composer
    print_info "Testing Composer installations..."
    if docker exec "$CONTAINER_NAME" php7.4 /usr/local/bin/composer --version &> /dev/null; then
        print_success "Composer with PHP 7.4 is working"
    else
        print_warning "Composer with PHP 7.4 may have issues"
    fi
    
    if docker exec "$CONTAINER_NAME" php8.4 /usr/local/bin/composer --version &> /dev/null; then
        print_success "Composer with PHP 8.4 is working"
    else
        print_warning "Composer with PHP 8.4 may have issues"
    fi
    
    # Check final status
    if docker compose ps --services --filter "status=running" | grep -q .; then
        print_success "Environment successfully rebuilt and running!"
        docker compose ps
    else
        print_error "Failed to start some services after rebuild. Check logs with: docker compose logs"
        exit 1
    fi
}

# Function to reload services with updated configuration
reload_services() {
    print_info "Reloading IUM services with updated configuration..."
    
    if ! docker compose version &> /dev/null; then
        print_error "Docker Compose is not available. Please ensure Docker is installed and running."
        exit 1
    fi
    
    cd "$DOCKER_COMPOSE_DIR"
    
    print_info "Restarting containers to apply configuration changes..."
    docker compose restart
    
    # Wait for services to initialize
    print_info "Waiting for services to initialize..."
    sleep 5
    
    # Gracefully reload services without forcing restarts
    print_info "Reloading configuration and services..."
    
    # First, update supervisor configuration
    docker exec "$CONTAINER_NAME" supervisorctl reread 2>/dev/null || true
    docker exec "$CONTAINER_NAME" supervisorctl update 2>/dev/null || true
    
    # Check and start services if needed (don't force restart if already running)
    print_info "Ensuring services are running..."
    
    # Check PHP 7.4 FPM
    if ! docker exec "$CONTAINER_NAME" supervisorctl status php7.4-fpm | grep -q "RUNNING"; then
        print_info "Starting PHP 7.4 FPM..."
        docker exec "$CONTAINER_NAME" supervisorctl start php7.4-fpm 2>/dev/null || true
    else
        print_success "PHP 7.4 FPM is running"
    fi
    
    # Check PHP 8.4 FPM
    if ! docker exec "$CONTAINER_NAME" supervisorctl status php8.4-fpm | grep -q "RUNNING"; then
        print_info "Starting PHP 8.4 FPM..."
        docker exec "$CONTAINER_NAME" supervisorctl start php8.4-fpm 2>/dev/null || true
    else
        print_success "PHP 8.4 FPM is running"
    fi
    
    # Check Apache - if not running via supervisor, start it directly
    if ! docker exec "$CONTAINER_NAME" supervisorctl status apache2 | grep -q "RUNNING"; then
        print_info "Starting Apache..."
        # Try supervisor first, if that fails, start directly
        if ! docker exec "$CONTAINER_NAME" supervisorctl start apache2 2>/dev/null; then
            print_info "Starting Apache directly..."
            docker exec "$CONTAINER_NAME" apache2ctl start 2>/dev/null || true
        fi
    else
        print_success "Apache is running"
    fi
    
    # Reload Apache configuration without restarting
    print_info "Reloading Apache configuration..."
    docker exec "$CONTAINER_NAME" apache2ctl graceful 2>/dev/null || print_warning "Could not gracefully reload Apache"
    
    # Final status check
    print_info "Service status check..."
    docker exec "$CONTAINER_NAME" supervisorctl status
    
    print_success "Configuration reload completed!"
    print_info "Updated configuration files are now active"
    
    # Update hosts file too
    update_hosts_file
}

# Function to completely uninstall IUM environment
uninstall_environment() {
    print_warning "This will completely remove the IUM development environment!"
    print_warning "This includes:"
    print_warning "  - All Docker containers and images"
    print_warning "  - All volumes and data (databases, files, etc.)"
    print_warning "  - Hosts file entries for .local domains"
    print_warning "  - NOTE: Your application code in www/ directory will NOT be deleted"
    echo ""
    
    # Confirmation prompt
    echo -n "Are you sure you want to uninstall? Type 'yes' to confirm: "
    read -r confirmation
    
    if [[ "$confirmation" != "yes" ]]; then
        print_info "Uninstall cancelled"
        return
    fi
    
    cd "$DOCKER_COMPOSE_DIR"
    
    print_info "Stopping and removing containers..."
    if docker compose ps --services 2>/dev/null | grep -q .; then
        docker compose down --volumes --remove-orphans 2>/dev/null || true
    fi
    
    print_info "Removing Docker images..."
    # Remove IUM-specific images
    docker images --format "table {{.Repository}}:{{.Tag}}" | grep -E "^ium-|^localhost.*ium" | while read -r image; do
        if [[ -n "$image" && "$image" != "REPOSITORY:TAG" ]]; then
            print_info "Removing image: $image"
            docker rmi "$image" 2>/dev/null || true
        fi
    done
    
    # Remove any dangling volumes
    print_info "Removing unused volumes..."
    docker volume prune -f 2>/dev/null || true
    
    # Clean up hosts file
    print_info "Cleaning up hosts file entries..."
    remove_hosts_entries
    
    # Clean up data directories (but preserve structure)
    print_info "Cleaning up data directories..."
    if [[ -d "data/mysql" ]]; then
        rm -rf data/mysql/* 2>/dev/null || true
    fi
    if [[ -d "data/redis" ]]; then
        rm -rf data/redis/* 2>/dev/null || true
    fi
    if [[ -d "logs" ]]; then
        rm -rf logs/apache/* 2>/dev/null || true
    fi
    
    print_success "IUM development environment has been completely uninstalled!"
    print_info "Your application code in the www/ directory has been preserved"
    print_info "To reinstall, run: ./ium wake"
}

# Function to remove hosts file entries
remove_hosts_entries() {
    if [[ ! -w "$HOSTS_FILE" ]]; then
        print_info "Requesting sudo access to modify $HOSTS_FILE"
        sudo -v
    fi
    
    # Create temporary file without IUM entries
    local temp_hosts=$(mktemp)
    
    # Copy hosts file without IUM section
    awk "
        /^${IUM_MARKER}/,/^${IUM_MARKER} END/ { next }
        { print }
    " "$HOSTS_FILE" > "$temp_hosts"
    
    # Replace hosts file
    if [[ -w "$HOSTS_FILE" ]]; then
        cp "$temp_hosts" "$HOSTS_FILE"
    else
        sudo cp "$temp_hosts" "$HOSTS_FILE"
    fi
    
    rm "$temp_hosts"
    print_success "Removed .local domain entries from hosts file"
}

# Function to update hosts file
update_hosts_file() {
    print_info "Scanning for applications..."
    
    local apps=($(scan_applications))
    
    if [[ ${#apps[@]} -eq 0 ]]; then
        print_warning "No applications found to add to hosts file"
        return
    fi
    
    print_info "Found ${#apps[@]} applications: ${apps[*]}"
    
    # Check if we need sudo
    if [[ ! -w "$HOSTS_FILE" ]]; then
        print_info "Requesting sudo access to modify $HOSTS_FILE"
        
        # Create temporary file with new entries
        local temp_file=$(mktemp)
        
        # Copy existing hosts file without IUM entries
        grep -v "$IUM_MARKER" "$HOSTS_FILE" > "$temp_file" 2>/dev/null || true
        
        # Add IUM marker and entries
        echo "" >> "$temp_file"
        echo "$IUM_MARKER - Start" >> "$temp_file"
        
        for app in "${apps[@]}"; do
            echo "127.0.0.1    $app.local" >> "$temp_file"
        done
        
        echo "$IUM_MARKER - End" >> "$temp_file"
        
        # Update hosts file with sudo
        sudo cp "$temp_file" "$HOSTS_FILE"
        rm "$temp_file"
    else
        # Direct modification (probably won't happen, but just in case)
        print_error "Cannot write to hosts file. Please run with appropriate permissions."
        exit 1
    fi
    
    print_success "Updated hosts file with ${#apps[@]} applications"
    
    # Show added entries
    print_info "Added the following entries:"
    for app in "${apps[@]}"; do
        echo "  $app.local -> 127.0.0.1"
    done
}

# Function to show help
show_help() {
    echo "IUM Development Environment CLI Tool"
    echo ""
    echo "Usage:"
    echo "  ium <command>           Execute any command in detected environment"
    echo "  ium wake                Start all containers"
    echo "  ium sleep               Stop all containers"
    echo "  ium reborn              Rebuild and restart all containers"
    echo "  ium reload              Reload services with updated configuration and hosts"
    echo "  ium status              Show environment status"
    echo "  ium help                Show this help message"
    echo ""
    echo "Container Management:"
    echo "  ium wake                Start the development environment"
    echo "  ium sleep               Stop the development environment"
    echo "  ium reborn              Rebuild containers from scratch"
    echo "  ium reload              Restart services with updated config files"
    echo "  ium uninstall           Completely remove IUM environment"
    echo ""
    echo "Examples:"
    echo "  ium wake                Start all services"
    echo "  ium reborn              Rebuild after Dockerfile changes"
    echo "  ium reload              Restart services with updated config files"
    echo "  ium uninstall           Completely remove environment"
    echo "  ium php -v              Show PHP version"
    echo "  ium php artisan about   Run Laravel Artisan command"
    echo "  ium composer install    Install Composer dependencies"
    echo "  ium node --version      Show Node.js version"
    echo "  ium npm install         Install NPM dependencies"
    echo "  ium npm run dev         Run NPM development script"
    echo "  ium git status          Check git status"
    echo "  ium ls -la              List files in container"
    echo "  ium bash                Open interactive shell"
    echo "  ium sleep               Stop all services"
    echo ""
    echo "Notes:"
    echo "  - Run commands from within your application directory"
    echo "  - PHP version is automatically detected from directory structure"
    echo "  - Node.js LTS and npm are available globally in all environments"
    echo "  - Commands are executed inside the container with proper context"
    echo "  - Applications are accessible via <appname>.local domains"
    echo "  - Use 'reborn' after making changes to Dockerfile or configs"
    echo ""
}

# Function to show status
show_status() {
    print_info "IUM Development Environment Status"
    echo ""
    
    # Check Docker Compose
    if docker compose -f "$DOCKER_COMPOSE_DIR/docker-compose.yml" ps --services --filter "status=running" | grep -q .; then
        print_success "Docker Compose services are running"
        docker compose -f "$DOCKER_COMPOSE_DIR/docker-compose.yml" ps
    else
        print_warning "Docker Compose services are not running"
        echo "Start with: cd $DOCKER_COMPOSE_DIR && docker compose up -d"
    fi
    
    echo ""
    
    # Show detected environment
    local php_version=$(detect_php_version)
    local app_name=$(get_app_name)
    
    print_info "Current Environment:"
    echo "  PHP Version: $php_version"
    if [[ -n "$app_name" ]]; then
        echo "  Application: $app_name"
        echo "  URL: http://$app_name.local"
    else
        echo "  Application: Not in app directory"
    fi
    
    echo ""
    
    # Show available applications
    local apps=($(scan_applications))
    if [[ ${#apps[@]} -gt 0 ]]; then
        print_info "Available Applications:"
        for app in "${apps[@]}"; do
            echo "  $app -> http://$app.local"
        done
    else
        print_warning "No applications found"
    fi
}

# Main script logic
main() {
    case "${1:-help}" in
        "wake")
            wake_containers
            ;;
        "sleep")
            sleep_containers
            ;;
        "reborn")
            reborn_containers
            ;;
        "reload")
            reload_services
            ;;
        "uninstall")
            uninstall_environment
            ;;
        "help"|"--help"|"-h")
            show_help
            ;;
        "status")
            show_status
            ;;
        *)
            # Execute command
            local php_version=$(detect_php_version)
            local app_name=$(get_app_name)
            
            if [[ $? -ne 0 && -z "$app_name" ]]; then
                print_warning "Not in an application directory. Using default PHP version: $php_version"
            fi
            
            execute_command "$php_version" "$@"
            ;;
    esac
}

# Run main function with all arguments
main "$@"
